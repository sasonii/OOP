Object subclass: #Monom	instanceVariableNames: 'exp coef'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Monom methodsFor: 'coef' stamp: 'rh 4/10/2021 19:07'!coef	^coef.! !!Monom methodsFor: 'coef' stamp: 'rh 4/21/2021 20:11'!coef: anInteger	(anInteger isKindOf: SmallInteger) ifTrue: [			coef := anInteger deepCopy.		^self.	]	ifFalse: [self error: 'invalid input']! !!Monom methodsFor: 'derivative' stamp: 'rh 4/10/2021 19:01'!derivative | param |	param := Monom new.	(self exp > 0) ifTrue:[	param exp: (self exp - 1).	param coef: ((self exp) * (self coef)).	] ifFalse:[	param exp: 0.	param coef: 0.	].	^param! !!Monom methodsFor: 'initialize-release' stamp: 'rh 4/10/2021 17:23'!initialize	exp := 0. 	coef := 0! !!Monom methodsFor: 'exp' stamp: 'a 4/6/2021 15:55'!exp 	^exp! !!Monom methodsFor: 'exp' stamp: 'rh 4/21/2021 20:11'!exp: anInteger	((anInteger isKindOf: SmallInteger) and: [anInteger >= 0]) ifTrue: [			exp := anInteger.		^self.	]	ifFalse: [self error: 'invalid input']! !Object subclass: #PolyStream	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!PolyStream methodsFor: 'add' stamp: 'rh 4/21/2021 20:12'!add: aPolyStream |polynom|	(aPolyStream isKindOf: PolyStream) ifTrue:[			(self == aPolyStream) ifTrue:[				self multiplyBy:2.			] 			ifFalse:[ 				polynom := Dictionary new.				polynom at:(((aPolyStream block) value:10 value:[]) deepCopy) put:(aPolyStream).				(self block) value:2 value:polynom.			]		]		ifFalse:[self error:'invalid input']! !!PolyStream methodsFor: 'add' stamp: 'rh 4/21/2021 20:12'!addCoef: coef withExp: exp | monom |	((coef isKindOf:SmallInteger) and:[(exp isKindOf:SmallInteger) and:[(exp > 0) or:[(exp = 0)]]]) ifTrue:[			monom := [:int :op| 				(op = 0) ifTrue:[(int raisedTo:(exp deepCopy)) * (coef deepCopy)] ifFalse:[				(op = 1) ifTrue:[exp].				].			].			(self block) value:0 value:monom.		] ifFalse:[self error:'invalid input'].! !!PolyStream methodsFor: 'initialize-release' stamp: 'rh 4/20/2021 19:38'!initialize | time monoms tmp polynoms sets subs muls|	time := 0.	muls := LinkedList new.	subs := LinkedList new.	sets := LinkedList new.	polynoms := LinkedList new.	monoms := LinkedList new.	block := [ :op :blockParam | 		(op = 0) ifTrue:[tmp := Dictionary new.			tmp at:time put:blockParam.			monoms add:tmp. time := time + 1] ifFalse:[					(op = 1) ifTrue:[monoms] ifFalse:[					(op = 2) ifTrue:[tmp := Dictionary new.			tmp at:time put:blockParam.			polynoms add:tmp. time := time + 1] ifFalse:[		(op = 3) ifTrue:[polynoms] ifFalse:[		(op = 4) ifTrue:[tmp := Dictionary new.			tmp at:time put:blockParam.			sets add:tmp. time := time + 1] ifFalse:[		(op = 5) ifTrue:[sets] ifFalse:[				(op = 6) ifTrue:[tmp := Dictionary new.			tmp at:time put:blockParam.			subs add:tmp. time := time + 1] ifFalse:[		(op = 7) ifTrue:[subs] ifFalse:[		(op = 8) ifTrue:[tmp := Dictionary new.			tmp at:time put:blockParam.			muls add:tmp. time := time + 1] ifFalse:[		(op = 9) ifTrue:[muls] ifFalse:[		(op = 10) ifTrue:[time]		]]]]]]]]]]].! !!PolyStream methodsFor: 'filter' stamp: 'rh 4/21/2021 20:12'!filter: aSet	(aSet isKindOf:Set) ifTrue:[(self block) value:4 value:(aSet veryDeepCopy).] 		ifFalse:[self error:'invalid input'].! !!PolyStream methodsFor: 'eval' stamp: 'rh 4/21/2021 20:12'!eval: anInteger | res myPolynoms p myFilters myMul mySub filters|	(anInteger isKindOf:SmallInteger) ifFalse:[		self error:'invalid input'		] 	ifTrue:[		myMul := (self block) value:9 value:[]. "list of dictionaries: key=time value=mul - type Integer"		mySub := (self block) value:7 value:[]. "list of dictionaries: key=time value=sub - type Integer"		myFilters := (self block) value:5 value:[]. "list of dictionaries: key=time value=aSet - type Set"		myPolynoms := (self block) value:3 value:[]. "list of dictionaries: key=time value=(Dictionary: key=the polynom time when it added value:PolyStream of the polynom)"		res := (self evalMyMonoms: anInteger).		myPolynoms do:[:polyDict |			polyDict keysDo:[:outerTime |				filters := Set new.				myFilters do:[:setDict|					setDict keysDo:[:time|						(time > outerTime) ifTrue:[filters addAll:(setDict at:time)] "include all the sets that entered after the current polynom had been added"					].				].				p := polyDict at:outerTime. "p is a Dictionary: key=the polynom time when it added value:PolyStream of the polynom"				p keysDo:[:innerTime | 					res := res + ((p at:innerTime) evalExtendedWith: filters With:myMul With:mySub With:innerTime With:outerTime At:anInteger).					]				]			].		^res.		]! !!PolyStream methodsFor: 'eval' stamp: 'rh 4/20/2021 23:07'!evalExtendedWith: filters With:muls With:subs With:innerTime With:outerTime At:integer |myTime myFilters myMul mySub myMonoms myPolynoms mul sub sum p tmpFilter| 	"	outerTime - the time stamp the sender gave me when i were added to it.	innerTime - the time stamp i had when i have been added to the sender.	filters - set of all the exponnets that should take out of the cuurent polynom	"	sum := 0.	mul := 1.	sub := 1.	myTime := (self block) value:10 value:[]. "integer"	myMul := (self block) value:9 value:[]. "list of Dictionaries: key=time relative to me. value=mul"	mySub := (self block) value:7 value:[]. "list of Dictionaries: key=time relative to me. value=sub"	myFilters := (self block) value:5 value:[]. "list of dictionaries: key=time relative to me. value=set of integer"	myMonoms := (self block) value:1 value:[]. "list of dictionaries: key=time value=block, op=0 calculates, op=1 get exponent"	myPolynoms := (self block) value:3 value:[]. "list of dictionaries: key=time value=(Dictionary: key=the polynom time when it added value:PolyStream of the polynom)"		myMonoms do:[:monomDict |		mul := 1.		sub := 1.		monomDict keysDo:[:monomInnerTime|			((monomInnerTime > innerTime) or:[monomInnerTime = innerTime]) ifTrue:[mul := 0] "the current monom added after this polynom added to it's sender"			ifFalse:[ "should check this monom"				myFilters do:[:filterDict |					filterDict keysDo:[:filterInnerTime |						((filterInnerTime < innerTime) and:[((filterInnerTime > monomInnerTime) and:[(filterDict at:filterInnerTime) includes:((monomDict at:monomInnerTime) value:0 value:1)])]) ifTrue:[							mul := 0] "filter according to inner filter (my filters)"					]				].				(filters includes:((monomDict at:monomInnerTime) value:0 value:1)) ifTrue:[mul = 0]. "remove monoms according the given filters"				myMul do:[:mulDict |					mulDict keysDo:[:mulInnerTime |					((mulInnerTime < innerTime) and:[(mulInnerTime > monomInnerTime)]) ifTrue:[mul := mul * (mulDict at:mulInnerTime)] 					"the monom was in this polynom before the current mul and the current mul was in the polynom before it had been added to the sender"						]				].				muls do:[:mulDict |					mulDict keysDo:[:mulOuterTime |						(mulOuterTime > outerTime) ifTrue:[mul := mul * (mulDict at:mulOuterTime)]						"the monom should be multiplied as part of the polynom"					]				].								mySub do:[:subDict |					subDict keysDo:[:subInnerTime |					((subInnerTime < innerTime) and:[(subInnerTime > monomInnerTime)]) ifTrue:[sub := sub * (subDict at:subInnerTime)] 					"the monom was in this polynom before the current subtitution and the current subtitution was in the polynom before it had been added to the sender"						]				].				subs do:[:subDict |					subDict keysDo:[:subOuterTime |						(subOuterTime > outerTime) ifTrue:[sub := sub * (subDict at:subOuterTime)]						"the monom should make the subtitution as part of the polynom"					]				]									].			sum := sum + (mul * ((monomDict at:monomInnerTime) value:(sub * integer) value:0)).		].	].	myPolynoms do:[:polyDict |		mul := 1.		sub := 1.		polyDict keysDo:[:theTimeIGave |				muls do:[:mulDict |				mulDict keysDo:[:mulOuterTime |					(mulOuterTime > theTimeIGave) ifTrue:[mul := mul * (mulDict at:mulOuterTime)]					"the polynom should be multiplied as part of the polynom"				]			].			subs do:[:subDict |				subDict keysDo:[:subOuterTime |					(subOuterTime > theTimeIGave) ifTrue:[sub := sub * (subDict at:subOuterTime)]					"the monom polynom make the subtitution as part of the polynom"				]			].			p := polyDict at:theTimeIGave.			p keysDo:[:theTimeItHad |				tmpFilter := filters veryDeepCopy.				myFilters do:[:setDict |				setDict keysDo:[:time|					((time > theTimeIGave) and:[(time < innerTime)]) ifTrue:[tmpFilter addAll:(setDict at:time)] "include all the sets that entered after the current polynom had been added"					].				].				sum := sum + (mul * ((p at:theTimeItHad) evalExtendedWith: tmpFilter With:myMul With:mySub With:theTimeItHad With:theTimeIGave At:(sub * integer)))			]		]	].	^sum.! !!PolyStream methodsFor: 'eval' stamp: 'rh 4/20/2021 22:57'!evalMyMonoms: anInteger | sum myMul mySub myFilters myMonoms mul sub x tmp |	sum := 0.	myMul := (self block) value:9 value:[]. "list of dictionaries: key=time value=mul - type Integer"	mySub := (self block) value:7 value:[]. "list of dictionaries: key=time value=sub - type Integer"	myFilters := (self block) value:5 value:[]. "list of dictionaries: key=time value=aSet - type Set"	myMonoms := (self block) value:1 value:[]. "list of dictionaries:key=time value=block that recives integer and op, op=0 calculates, op=1 get exponent"		myMonoms do:[:monomDict| 		mul := 1.		sub := 1.		monomDict keysDo:[:monomTime |			myFilters do:[:setDict |				setDict keysDo:[:setTime |					"the set has been added after the monom added and it includes it's exponet"					((setTime > monomTime) and:[((setDict at:setTime) includes:((monomDict at:monomTime) value:0 value:1))]) ifTrue:[mul := 0]. 					].				].			myMul do:[:mulDict|				mulDict keysDo:[:mulTime | 					(mulTime > monomTime) ifTrue:[mul := mul * (mulDict at:mulTime)].					].				].			mySub do:[:subDict | 				subDict keysDo:[:subTime |					(subTime > monomTime) ifTrue:[sub := sub * (subDict at:subTime)].					].				].			x := (anInteger * sub).			tmp :=((monomDict at:monomTime) value:x value:0).			tmp := mul * tmp.			sum := sum + tmp.		].	].	^sum.! !!PolyStream methodsFor: 'eval' stamp: 'a 4/13/2023 18:48'!eval_my_monoms: anInteger |sum my_monoms my_subs my_muls my_filters final_mul final_sub final_x|	sum := 0.	my_monoms := (self block) value:1 value:[].	my_subs := (self block) value:5 value:[].	my_muls := (self block) value:7 value:[].	my_filters := (self block) value:9 value:[].	my_monoms do: [:monom_dictionary |		final_mul := 1.		final_sub := 1.		"NOTE that each :monom_dictionary has only one (key, value) pair"		monom_dictionary keysDo: [:monom_time|			my_filters do:[:filter_dictionary|				filter_dictionary keysDo: [:filter_time|				((filter_time > monom_time) & ((filter_dictionary at: filter_time) includes: ((monom_dictionary at: monom_time) value:1 value:1) )) ifTrue:[final_mul :=0]]].					my_muls do: [:mul_dictionary|				mul_dictionary keysDo: [:mul_time|					(mul_time > monom_time) ifTrue: [final_mul := final_mul * (mul_dictionary at: mul_time)]]].						my_subs do: [:sub_dictionary|				sub_dictionary keysDo: [:sub_time|					(sub_time > monom_time) ifTrue: [final_sub := final_sub * (sub_dictionary at: sub_time)]]].			].		monom_dictionary valuesDo: [:monom_block|			final_x := final_sub * anInteger.			sum := sum + (final_mul *(monom_block value: final_x value: 0)).			].				].	^sum.! !!PolyStream methodsFor: 'eval' stamp: 'a 4/13/2023 18:48'!eval_polystream: polynom_time with: other_subs with: other_muls with: other_filters_as_set at: anInteger 	|sum my_monoms my_polynoms my_subs my_muls my_filters final_mul final_sub final_x temp_filter|	sum := 0.	my_monoms := (self block) value:1 value:[].	my_polynoms := (self block) value: 3 value: [].	my_subs := (self block) value:5 value:[].	my_muls := (self block) value:7 value:[].	my_filters := (self block) value:9 value:[].	my_monoms do: [:monom_dictionary |		final_mul := 1.		final_sub := 1.		"NOTE that each :monom_dictionary has only one (key, value) pair"		monom_dictionary keysDo: [:monom_inner_time|			my_filters do:[:filter_dictionary|				filter_dictionary keysDo: [:filter_time|				((filter_time > monom_inner_time) & ((filter_dictionary at: filter_time) includes: ((monom_dictionary at: monom_inner_time) value:1 value:1) )) ifTrue:[final_mul :=0]]].					my_muls do: [:mul_dictionary|				mul_dictionary keysDo: [:mul_time|					(mul_time > monom_inner_time) ifTrue: [final_mul := final_mul * (mul_dictionary at: mul_time)]]].						my_subs do: [:sub_dictionary|				sub_dictionary keysDo: [:sub_time|					(sub_time > monom_inner_time) ifTrue: [final_sub := final_sub * (sub_dictionary at: sub_time)]]].						(other_filters_as_set includes: ((monom_dictionary at: monom_inner_time) value:1 value:1)) ifTrue:[final_mul := 0].					other_muls do: [:mul_dictionary|				mul_dictionary keysDo: [:mul_time|					(mul_time > polynom_time) ifTrue: [final_mul := final_mul * (mul_dictionary at: mul_time)]]].						other_subs do: [:sub_dictionary|				sub_dictionary keysDo: [:sub_time|					(sub_time > polynom_time) ifTrue: [final_sub := final_sub * (sub_dictionary at: sub_time)]]].						].		monom_dictionary valuesDo: [:monom_block|			final_x := final_sub * anInteger.			sum := sum + (final_mul *(monom_block value: final_x value: 0)).			].				].		my_polynoms do: [:polynom_dictionary|			final_mul := 1.			final_sub := 1.			polynom_dictionary keysDo: [:other_polynom_time|				temp_filter := Set new.				temp_filter := other_filters_as_set veryDeepCopy.				temp_filter do: [:filter_dictionary|				filter_dictionary keysDo: [:filter_time|					(filter_time > other_polynom_time) ifTrue:[temp_filter addAll:(filter_dictionary at: filter_time)]]].			sum := sum + ((polynom_dictionary at: other_polynom_time) eval_polystream:polynom_time with: my_subs with: my_muls with: temp_filter) at: anInteger.			]		].		^sum.	! !!PolyStream methodsFor: 'eval' stamp: 'a 4/13/2023 18:46'!eval_polystream: polynom_time with: other_subs with: other_muls with: other_filters_as_set with: anInteger 	|sum my_monoms my_polynoms my_subs my_muls my_filters final_mul final_sub final_x temp_filter|	sum := 0.	my_monoms := (self block) value:1 value:[].	my_polynoms := (self block) value: 3 value: [].	my_subs := (self block) value:5 value:[].	my_muls := (self block) value:7 value:[].	my_filters := (self block) value:9 value:[].	my_monoms do: [:monom_dictionary |		final_mul := 1.		final_sub := 1.		"NOTE that each :monom_dictionary has only one (key, value) pair"		monom_dictionary keysDo: [:monom_inner_time|			my_filters do:[:filter_dictionary|				filter_dictionary keysDo: [:filter_time|				((filter_time > monom_inner_time) & ((filter_dictionary at: filter_time) includes: ((monom_dictionary at: monom_inner_time) value:1 value:1) )) ifTrue:[final_mul :=0]]].					my_muls do: [:mul_dictionary|				mul_dictionary keysDo: [:mul_time|					(mul_time > monom_inner_time) ifTrue: [final_mul := final_mul * (mul_dictionary at: mul_time)]]].						my_subs do: [:sub_dictionary|				sub_dictionary keysDo: [:sub_time|					(sub_time > monom_inner_time) ifTrue: [final_sub := final_sub * (sub_dictionary at: sub_time)]]].						(other_filters_as_set includes: ((monom_dictionary at: monom_inner_time) value:1 value:1)) ifTrue:[final_mul := 0].					other_muls do: [:mul_dictionary|				mul_dictionary keysDo: [:mul_time|					(mul_time > polynom_time) ifTrue: [final_mul := final_mul * (mul_dictionary at: mul_time)]]].						other_subs do: [:sub_dictionary|				sub_dictionary keysDo: [:sub_time|					(sub_time > polynom_time) ifTrue: [final_sub := final_sub * (sub_dictionary at: sub_time)]]].						].		monom_dictionary valuesDo: [:monom_block|			final_x := final_sub * anInteger.			sum := sum + (final_mul *(monom_block value: final_x value: 0)).			].				].		my_polynoms do: [:polynom_dictionary|			final_mul := 1.			final_sub := 1.			polynom_dictionary keysDo: [:other_polynom_time|				temp_filter := Set new.				temp_filter := other_filters_as_set veryDeepCopy.				temp_filter do: [:filter_dictionary|				filter_dictionary keysDo: [:filter_time|					(filter_time > other_polynom_time) ifTrue:[temp_filter addAll:(filter_dictionary at: filter_time)]]].								my_muls do: [:mul_dictionary|					mul_dictionary keysDo: [:mul_time|						(mul_time > other_polynom_time) ifTrue: [final_mul := final_mul * (mul_dictionary at: mul_time)]]].							my_subs do: [:sub_dictionary|					sub_dictionary keysDo: [:sub_time|						(sub_time > other_polynom_time) ifTrue: [final_sub := final_sub * (sub_dictionary at: sub_time)]]].										sum := sum + (final_mul * ((polynom_dictionary at: other_polynom_time) eval_polystream:polynom_time with: my_subs with: my_muls with: temp_filter at: (anInteger * final_sub))).			]		].		^sum.	! !!PolyStream methodsFor: 'mul' stamp: 'rh 4/21/2021 20:12'!multiplyBy: anInteger	(anInteger isKindOf: SmallInteger) ifFalse:[self error:'invalid input'] ifTrue:[		(self block) value:8 value:(anInteger deepCopy)	].! !!PolyStream methodsFor: 'accessing' stamp: 'rh 4/19/2021 17:24'!block		^block.! !!PolyStream methodsFor: 'substitute' stamp: 'rh 4/21/2021 20:13'!substitute: anInteger	((anInteger isKindOf: SmallInteger) and:[anInteger ~= 0])  ifTrue:[		(self block) value:6 value:(anInteger deepCopy).]	ifFalse:[self error:'invalid input'].! !Object subclass: #Polynom	instanceVariableNames: 'monoms'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Polynom methodsFor: 'asDictionary' stamp: 'rh 4/21/2021 12:53'!asDictionary | dict |	dict := Dictionary new.	(monoms isEmpty) ifTrue:[^dict]	ifFalse:[				monoms do:[:x | dict add:(Association key: (x exp) value:(x coef))].			^dict.			].		! !!Polynom methodsFor: 'derivative' stamp: 'rh 4/10/2021 19:14'!derivative | poly tmp|	poly := Polynom new.	monoms do: [:m |tmp := (m derivative). (tmp coef ~= 0) ifTrue:[poly addMonom: tmp].].	^poly! !!Polynom methodsFor: 'eval' stamp: 'rh 4/21/2021 20:13'!eval: anInteger |sum|	(anInteger isKindOf: SmallInteger) ifTrue:[			sum := 0.			monoms do: [:m | sum := sum + ((anInteger raisedTo: (m exp)) * (m coef)) ].			^sum.		]	ifFalse:[		self error: 'invalid input'.		] ! !!Polynom methodsFor: 'add' stamp: 'a 4/19/2023 00:43'!add: aPolynom | poly |	poly := Polynom new.	poly := aPolynom veryDeepCopy.	(aPolynom isKindOf: Polynom) ifTrue: [					 (self monoms) do: [:m | poly addMonom: m].		^poly.				]	ifFalse: [ self error: 'invalid input'].! !!Polynom methodsFor: 'multiplyByMonom' stamp: 'rh 4/21/2021 20:13'!multiplyByMonom: aMonom	(aMonom isKindOf: Monom) ifFalse: [self error: 'invalid input']	ifTrue:[ ((aMonom coef) = 0) ifTrue:[monoms := LinkedList new]		ifFalse:[				monoms := monoms collect: [:m | m exp: ((m exp) + (aMonom exp)). m coef: ((m coef) * (aMonom coef))]			]		].	! !!Polynom methodsFor: 'initialize-release' stamp: 'rh 4/10/2021 17:40'!initialize	monoms :=  LinkedList new.! !!Polynom methodsFor: 'addMonom' stamp: 'rh 4/21/2021 20:13'!addMonom: aMonom | list tmp flag |	list := LinkedList new.	flag := 0.	(aMonom isKindOf: Monom) ifTrue: [		monoms do:[:x| tmp := Monom new.			((x exp) = (aMonom exp)) ifTrue:[tmp coef:((x coef) + (aMonom coef)).				tmp exp:(x exp). (tmp coef ~= 0) ifTrue:[list add:tmp.].				flag := 1.				] ifFalse:[list add:(x deepCopy).]			].		((flag = 0) and:[aMonom coef ~= 0]) ifTrue:[list add:aMonom].		monoms := list deepCopy.		]		ifFalse: [self error: 'invalid input'.]	! !!Polynom methodsFor: 'list' stamp: 'rh 4/21/2021 12:40'!monoms	 ^monoms.! !