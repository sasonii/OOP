Object subclass: #Monom	instanceVariableNames: 'exp coef'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Monom methodsFor: 'coef' stamp: 'a 4/8/2023 15:23'!coef	^coef.! !!Monom methodsFor: 'coef' stamp: 'a 4/8/2023 17:26'!coef: anInteger	(anInteger isKindOf: Integer) ifTrue: [coef := anInteger.]  ifFalse: [self error: 'invalid input']! !!Monom methodsFor: 'derivative' stamp: 'a 4/8/2023 15:23'!derivative |new_monom|	new_monom := Monom new.	(self exp > 0) ifTrue: [		new_monom exp: (self exp - 1).		new_monom coef: ((self coef) *( self exp)).		] ifFalse: [		new_monom exp: 0.		new_monom coef: 0.		].	^new_monom! !!Monom methodsFor: 'initialize-release' stamp: 'a 4/4/2023 13:23'!initialize	exp :=0.	coef :=0.	! !!Monom methodsFor: 'exp' stamp: 'a 4/8/2023 15:23'!exp	^exp.! !!Monom methodsFor: 'exp' stamp: 'a 4/8/2023 15:23'!exp: anInteger	((anInteger isKindOf: Integer) & (anInteger >= 0)) ifTrue: [exp := anInteger.]  ifFalse: [self error: 'invalid input']! !Object subclass: #PolyStream	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!PolyStream methodsFor: 'block' stamp: 'a 4/8/2023 23:30'!block^block.! !!PolyStream methodsFor: 'add' stamp: 'a 4/13/2023 18:34'!add: aPolyStream	(aPolyStream isKindOf: PolyStream) 	ifTrue:[		(self block) value:2 value: aPolyStream.		]	ifFalse:[self error:'invalid input'].! !!PolyStream methodsFor: 'add' stamp: 'a 4/13/2023 18:34'!addCoef: coef withExp: exp |monom|	((coef isKindOf: Integer) & (exp isKindOf: Integer) & (exp >= 0)) 	ifTrue: [		monom := [:operation :number|			 (operation = 1) ifTrue: [(number raisedTo: exp) * coef].			 (operation = 0) ifTrue: [exp]].				(self block) value: 0 value: monom.		] 	ifFalse: [self error:'invalid input'].! !!PolyStream methodsFor: 'initialize-release' stamp: 'a 4/8/2023 23:27'!initialize |monoms polynoms subs muls filters time temp_arg|	time := 0.	monoms := LinkedList new.	polynoms := LinkedList new.	subs := LinkedList new.	filters := LinkedList new.	muls := LinkedList new.	block := [:op :arg|		(op = 0) ifTrue: [			temp_arg := Dictionary new.			temp_arg at: time put: arg.			monoms add: arg.			time:=time+1].		(op = 1) ifTrue: [monoms].		(op = 2) ifTrue: [			temp_arg := Dictionary new.			temp_arg at: time put: arg.			polynoms add: arg.			time:=time+1].		(op = 3) ifTrue: [polynoms].		(op = 4) ifTrue: [			temp_arg := Dictionary new.			temp_arg at: time put: arg.			subs add: arg.			time:=time+1].		(op = 5) ifTrue: [subs].		(op = 6) ifTrue: [			temp_arg := Dictionary new.			temp_arg at: time put: arg.			muls add: arg.			time:=time+1].		(op = 7) ifTrue: [muls].		(op = 8) ifTrue: [			temp_arg := Dictionary new.			temp_arg at: time put: arg.			filters add: arg.			time:=time+1].		(op = 9) ifTrue: [filters].		(op = 10) ifTrue: [time].		]! !!PolyStream methodsFor: 'filter' stamp: 'a 4/8/2023 23:50'!filter: aSet	(aSet isKindOf:Set) 	ifTrue:[block value:8 value:(aSet veryDeepCopy).] 	ifFalse:[self error:'invalid input'].! !!PolyStream methodsFor: 'eval' stamp: 'a 4/13/2023 18:48'!eval: anInteger |result my_polynoms my_subs my_muls my_filters recursive_filter|	(anInteger isKindOf: Integer) 	ifFalse:[self error:'invalid input']	ifTrue:[		my_polynoms := (self block) value: 3 value: [].		my_subs := (self block) value:5 value:[].		my_muls := (self block) value:7 value:[].		my_filters := (self block) value:9 value:[].		result := self eval_my_monoms: anInteger.		my_polynoms do: [:polynom_dictionary|			polynom_dictionary keysDo: [:polynom_time|				recursive_filter := Set new.				my_filters do: [:filter_dictionary|				filter_dictionary keysDo: [:filter_time|					(filter_time > polynom_time) ifTrue:[recursive_filter addAll:(filter_dictionary at: filter_time)]					]				].			result := result + ((polynom_dictionary at: polynom_time) eval_polystream:polynom_time with: my_subs with: my_muls with: recursive_filter).			]		]	].	^result.		! !!PolyStream methodsFor: 'eval' stamp: 'a 4/13/2023 18:48'!eval_my_monoms: anInteger |sum my_monoms my_subs my_muls my_filters final_mul final_sub final_x|	sum := 0.	my_monoms := (self block) value:1 value:[].	my_subs := (self block) value:5 value:[].	my_muls := (self block) value:7 value:[].	my_filters := (self block) value:9 value:[].	my_monoms do: [:monom_dictionary |		final_mul := 1.		final_sub := 1.		"NOTE that each :monom_dictionary has only one (key, value) pair"		monom_dictionary keysDo: [:monom_time|			my_filters do:[:filter_dictionary|				filter_dictionary keysDo: [:filter_time|				((filter_time > monom_time) & ((filter_dictionary at: filter_time) includes: ((monom_dictionary at: monom_time) value:1 value:1) )) ifTrue:[final_mul :=0]]].					my_muls do: [:mul_dictionary|				mul_dictionary keysDo: [:mul_time|					(mul_time > monom_time) ifTrue: [final_mul := final_mul * (mul_dictionary at: mul_time)]]].						my_subs do: [:sub_dictionary|				sub_dictionary keysDo: [:sub_time|					(sub_time > monom_time) ifTrue: [final_sub := final_sub * (sub_dictionary at: sub_time)]]].			].		monom_dictionary valuesDo: [:monom_block|			final_x := final_sub * anInteger.			sum := sum + (final_mul *(monom_block value: final_x value: 0)).			].				].	^sum.! !!PolyStream methodsFor: 'eval' stamp: 'a 4/13/2023 18:48'!eval_polystream: polynom_time with: other_subs with: other_muls with: other_filters_as_set at: anInteger 	|sum my_monoms my_polynoms my_subs my_muls my_filters final_mul final_sub final_x temp_filter|	sum := 0.	my_monoms := (self block) value:1 value:[].	my_polynoms := (self block) value: 3 value: [].	my_subs := (self block) value:5 value:[].	my_muls := (self block) value:7 value:[].	my_filters := (self block) value:9 value:[].	my_monoms do: [:monom_dictionary |		final_mul := 1.		final_sub := 1.		"NOTE that each :monom_dictionary has only one (key, value) pair"		monom_dictionary keysDo: [:monom_inner_time|			my_filters do:[:filter_dictionary|				filter_dictionary keysDo: [:filter_time|				((filter_time > monom_inner_time) & ((filter_dictionary at: filter_time) includes: ((monom_dictionary at: monom_inner_time) value:1 value:1) )) ifTrue:[final_mul :=0]]].					my_muls do: [:mul_dictionary|				mul_dictionary keysDo: [:mul_time|					(mul_time > monom_inner_time) ifTrue: [final_mul := final_mul * (mul_dictionary at: mul_time)]]].						my_subs do: [:sub_dictionary|				sub_dictionary keysDo: [:sub_time|					(sub_time > monom_inner_time) ifTrue: [final_sub := final_sub * (sub_dictionary at: sub_time)]]].						(other_filters_as_set includes: ((monom_dictionary at: monom_inner_time) value:1 value:1)) ifTrue:[final_mul := 0].					other_muls do: [:mul_dictionary|				mul_dictionary keysDo: [:mul_time|					(mul_time > polynom_time) ifTrue: [final_mul := final_mul * (mul_dictionary at: mul_time)]]].						other_subs do: [:sub_dictionary|				sub_dictionary keysDo: [:sub_time|					(sub_time > polynom_time) ifTrue: [final_sub := final_sub * (sub_dictionary at: sub_time)]]].						].		monom_dictionary valuesDo: [:monom_block|			final_x := final_sub * anInteger.			sum := sum + (final_mul *(monom_block value: final_x value: 0)).			].				].		my_polynoms do: [:polynom_dictionary|			final_mul := 1.			final_sub := 1.			polynom_dictionary keysDo: [:other_polynom_time|				temp_filter := Set new.				temp_filter := other_filters_as_set veryDeepCopy.				temp_filter do: [:filter_dictionary|				filter_dictionary keysDo: [:filter_time|					(filter_time > other_polynom_time) ifTrue:[temp_filter addAll:(filter_dictionary at: filter_time)]]].			sum := sum + ((polynom_dictionary at: other_polynom_time) eval_polystream:polynom_time with: my_subs with: my_muls with: temp_filter) at: anInteger.			]		].		^sum.	! !!PolyStream methodsFor: 'eval' stamp: 'a 4/13/2023 18:46'!eval_polystream: polynom_time with: other_subs with: other_muls with: other_filters_as_set with: anInteger 	|sum my_monoms my_polynoms my_subs my_muls my_filters final_mul final_sub final_x temp_filter|	sum := 0.	my_monoms := (self block) value:1 value:[].	my_polynoms := (self block) value: 3 value: [].	my_subs := (self block) value:5 value:[].	my_muls := (self block) value:7 value:[].	my_filters := (self block) value:9 value:[].	my_monoms do: [:monom_dictionary |		final_mul := 1.		final_sub := 1.		"NOTE that each :monom_dictionary has only one (key, value) pair"		monom_dictionary keysDo: [:monom_inner_time|			my_filters do:[:filter_dictionary|				filter_dictionary keysDo: [:filter_time|				((filter_time > monom_inner_time) & ((filter_dictionary at: filter_time) includes: ((monom_dictionary at: monom_inner_time) value:1 value:1) )) ifTrue:[final_mul :=0]]].					my_muls do: [:mul_dictionary|				mul_dictionary keysDo: [:mul_time|					(mul_time > monom_inner_time) ifTrue: [final_mul := final_mul * (mul_dictionary at: mul_time)]]].						my_subs do: [:sub_dictionary|				sub_dictionary keysDo: [:sub_time|					(sub_time > monom_inner_time) ifTrue: [final_sub := final_sub * (sub_dictionary at: sub_time)]]].						(other_filters_as_set includes: ((monom_dictionary at: monom_inner_time) value:1 value:1)) ifTrue:[final_mul := 0].					other_muls do: [:mul_dictionary|				mul_dictionary keysDo: [:mul_time|					(mul_time > polynom_time) ifTrue: [final_mul := final_mul * (mul_dictionary at: mul_time)]]].						other_subs do: [:sub_dictionary|				sub_dictionary keysDo: [:sub_time|					(sub_time > polynom_time) ifTrue: [final_sub := final_sub * (sub_dictionary at: sub_time)]]].						].		monom_dictionary valuesDo: [:monom_block|			final_x := final_sub * anInteger.			sum := sum + (final_mul *(monom_block value: final_x value: 0)).			].				].		my_polynoms do: [:polynom_dictionary|			final_mul := 1.			final_sub := 1.			polynom_dictionary keysDo: [:other_polynom_time|				temp_filter := Set new.				temp_filter := other_filters_as_set veryDeepCopy.				temp_filter do: [:filter_dictionary|				filter_dictionary keysDo: [:filter_time|					(filter_time > other_polynom_time) ifTrue:[temp_filter addAll:(filter_dictionary at: filter_time)]]].								my_muls do: [:mul_dictionary|					mul_dictionary keysDo: [:mul_time|						(mul_time > other_polynom_time) ifTrue: [final_mul := final_mul * (mul_dictionary at: mul_time)]]].							my_subs do: [:sub_dictionary|					sub_dictionary keysDo: [:sub_time|						(sub_time > other_polynom_time) ifTrue: [final_sub := final_sub * (sub_dictionary at: sub_time)]]].										sum := sum + (final_mul * ((polynom_dictionary at: other_polynom_time) eval_polystream:polynom_time with: my_subs with: my_muls with: temp_filter at: (anInteger * final_sub))).			]		].		^sum.	! !!PolyStream methodsFor: 'substitue' stamp: 'a 4/8/2023 23:49'!substitute: anInteger	((anInteger isKindOf: Integer) & (anInteger ~= 0))  	ifTrue:[block value:4 value: anInteger.]	ifFalse:[self error:'invalid input'].! !!PolyStream methodsFor: 'mul' stamp: 'a 4/8/2023 23:48'!multiplyBy: anInteger	(anInteger isKindOf: Integer) 	ifTrue:[block value:6 value:anInteger]	ifFalse:[self error:'invalid input'].! !Object subclass: #Polynom	instanceVariableNames: 'monoms'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Polynom methodsFor: 'asDictionary' stamp: 'a 4/8/2023 16:05'!asDictionary |dictionary|	dictionary := Dictionary new.	monoms do: [:m | dictionary add: (Association key: (m exp) value: (m coef))].	^dictionary.	! !!Polynom methodsFor: 'derivative' stamp: 'a 4/8/2023 16:14'!derivative |new_polynom temp_monom|	new_polynom := Polynom new.	monoms do: [:m | 		temp_monom := (m derivative).		((temp_monom coef) = 0) ifFalse: [new_polynom addMonom: temp_monom].		].	^new_polynom.	! !!Polynom methodsFor: 'eval' stamp: 'a 4/8/2023 16:46'!eval: anInteger	(anInteger isKindOf: Integer) ifTrue: [		^monoms inject: 0 into: [:x :m | x + ((anInteger raisedTo: (m exp)) * (m coef)) ].	]	ifFalse: [self error: 'invalid input']! !!Polynom methodsFor: 'add' stamp: 'a 4/8/2023 17:15'!add: aPolynom | temp_polynom|	temp_polynom := Polynom new.	temp_polynom := aPolynom veryDeepCopy.	(aPolynom isKindOf: Polynom) ifTrue: [		monoms do: [:m | temp_polynom addMonom: m].		^temp_polynom.		]	ifFalse: [ self error: 'invalid input'].! !!Polynom methodsFor: 'multiplyByMonom' stamp: 'a 4/8/2023 16:00'!multiplyByMonom: aMonom	(aMonom isKindOf: Monom) ifTrue: [		((aMonom coef) = 0) ifTrue: [monoms := LinkedList new]		ifFalse:[				monoms := monoms collect: [:m | m exp: ((m exp) + (aMonom exp)). m coef: ((m coef) * (aMonom coef))]			]		]	ifFalse: [self error: 'invalid input'].! !!Polynom methodsFor: 'initialize-release' stamp: 'a 4/8/2023 14:52'!initialize	monoms :=  LinkedList new.! !!Polynom methodsFor: 'addMonom' stamp: 'a 4/8/2023 15:49'!addMonom: aMonom |flag|	flag := 0.	(aMonom isKindOf: Monom) ifTrue: [		monoms do: [:m| 			((m exp) = (aMonom exp)) ifTrue: [				m coef: (m coef) + (aMonom coef). 				((m coef) = 0) ifTrue: [monoms remove: m].				flag := 1.				].			].		((flag = 0) & (aMonom coef ~= 0)) ifTrue: [monoms add: (aMonom deepCopy)].		]			ifFalse: [self error: 'invalid input'.]! !